diff --git a/image.go b/image.go
index 39c0930..f75af62 100644
--- a/image.go
+++ b/image.go
@@ -8,6 +8,7 @@ import (
 	"image/color"
 	"image/png"
 	"io"
+	"strings"
 
 	"git.sr.ht/~rockorager/vaxis/log"
 	"git.sr.ht/~rockorager/vaxis/octreequant"
@@ -16,6 +17,64 @@ import (
 	"golang.org/x/image/draw"
 )
 
+// placeholderChar is the kitty Unicode placeholder character U+10EEEE.
+// Terminals that support the kitty graphics protocol recognize this character
+// and replace it with the corresponding image tile.
+const placeholderChar = "\U0010EEEE"
+
+// rowColDiacritics maps indices 0..255 to Unicode combining characters used
+// by the kitty graphics protocol to encode row and column numbers in Unicode
+// image placeholders.  The table is derived from rowcolumn-diacritics.txt
+// shipped with kitty.
+var rowColDiacritics = [...]rune{
+	0x0305, 0x030D, 0x030E, 0x0310, 0x0312, 0x033D, 0x033E, 0x033F,
+	0x0346, 0x034A, 0x034B, 0x034C, 0x0350, 0x0351, 0x0352, 0x0357,
+	0x035B, 0x0363, 0x0364, 0x0365, 0x0366, 0x0367, 0x0368, 0x0369,
+	0x036A, 0x036B, 0x036C, 0x036D, 0x036E, 0x036F, 0x0483, 0x0484,
+	0x0485, 0x0486, 0x0487, 0x0592, 0x0593, 0x0594, 0x0595, 0x0597,
+	0x0598, 0x0599, 0x059C, 0x059D, 0x059E, 0x059F, 0x05A0, 0x05A1,
+	0x05A8, 0x05A9, 0x05AB, 0x05AC, 0x05AF, 0x05C4, 0x0610, 0x0611,
+	0x0612, 0x0613, 0x0614, 0x0615, 0x0616, 0x0617, 0x0657, 0x0658,
+	0x0659, 0x065A, 0x065B, 0x065D, 0x065E, 0x06D6, 0x06D7, 0x06D8,
+	0x06D9, 0x06DA, 0x06DB, 0x06DC, 0x06DF, 0x06E0, 0x06E1, 0x06E2,
+	0x06E4, 0x06E7, 0x06E8, 0x06EB, 0x06EC, 0x0730, 0x0732, 0x0733,
+	0x0735, 0x0736, 0x073A, 0x073D, 0x073F, 0x0740, 0x0741, 0x0743,
+	0x0745, 0x0747, 0x0749, 0x074A, 0x07EB, 0x07EC, 0x07ED, 0x07EE,
+	0x07EF, 0x07F0, 0x07F1, 0x07F3, 0x0816, 0x0817, 0x0818, 0x0819,
+	0x081B, 0x081C, 0x081D, 0x081E, 0x081F, 0x0820, 0x0821, 0x0822,
+	0x0823, 0x0825, 0x0826, 0x0827, 0x0829, 0x082A, 0x082B, 0x082C,
+	0x082D, 0x0951, 0x0953, 0x0954, 0x0F82, 0x0F83, 0x0F86, 0x0F87,
+	0x135D, 0x135E, 0x135F, 0x17DD, 0x193A, 0x1A17, 0x1A75, 0x1A76,
+	0x1A77, 0x1A78, 0x1A79, 0x1A7A, 0x1A7B, 0x1A7C, 0x1B6B, 0x1B6D,
+	0x1B6E, 0x1B6F, 0x1B70, 0x1B71, 0x1B72, 0x1B73, 0x1CD0, 0x1CD1,
+	0x1CD2, 0x1CDA, 0x1CDB, 0x1CE0, 0x1DC0, 0x1DC1, 0x1DC3, 0x1DC4,
+	0x1DC5, 0x1DC6, 0x1DC7, 0x1DC8, 0x1DC9, 0x1DCB, 0x1DCC, 0x1DD1,
+	0x1DD2, 0x1DD3, 0x1DD4, 0x1DD5, 0x1DD6, 0x1DD7, 0x1DD8, 0x1DD9,
+	0x1DDA, 0x1DDB, 0x1DDC, 0x1DDD, 0x1DDE, 0x1DDF, 0x1DE0, 0x1DE1,
+	0x1DE2, 0x1DE3, 0x1DE4, 0x1DE5, 0x1DE6, 0x1DFE, 0x20D0, 0x20D1,
+	0x20D4, 0x20D5, 0x20D6, 0x20D7, 0x20DB, 0x20DC, 0x20E1, 0x20E7,
+	0x20E9, 0x20F0, 0x2CEF, 0x2CF0, 0x2CF1, 0x2DE0, 0x2DE1, 0x2DE2,
+	0x2DE3, 0x2DE4, 0x2DE5, 0x2DE6, 0x2DE7, 0x2DE8, 0x2DE9, 0x2DEA,
+	0x2DEB, 0x2DEC, 0x2DED, 0x2DEE, 0x2DEF, 0x2DF0, 0x2DF1, 0x2DF2,
+	0x2DF3, 0x2DF4, 0x2DF5, 0x2DF6, 0x2DF7, 0x2DF8, 0x2DF9, 0x2DFA,
+	0x2DFB, 0x2DFC, 0x2DFD, 0x2DFE, 0x2DFF, 0xA66F, 0xA67C, 0xA67D,
+	0xA6F0, 0xA6F1, 0xA8E0, 0xA8E1, 0xA8E2, 0xA8E3, 0xA8E4, 0xA8E5,
+}
+
+// placeholderGrapheme builds the grapheme string for a kitty Unicode
+// placeholder cell at the given row and column within an image.
+func placeholderGrapheme(row, col int) string {
+	var b strings.Builder
+	b.WriteString(placeholderChar)
+	if row < len(rowColDiacritics) {
+		b.WriteRune(rowColDiacritics[row])
+	}
+	if col < len(rowColDiacritics) {
+		b.WriteRune(rowColDiacritics[col])
+	}
+	return b.String()
+}
+
 // Alpha value that we consider to be transparent enough to use default
 // background color
 const transparentEnough = 50
@@ -86,6 +145,12 @@ func (k *KittyImage) Draw(win Window) {
 	if atomicLoad(&k.encoding) {
 		return
 	}
+
+	if k.vx.inTmux {
+		k.drawUnicodePlaceholder(win)
+		return
+	}
+
 	col, row := win.Origin()
 	log.Trace("placing kitty image at cell %d,%d", col, row)
 	// the pid is a 32 bit number where the high 16bits are the width and
@@ -97,10 +162,96 @@ func (k *KittyImage) Draw(win Window) {
 			atomicStore(&k.uploaded, true)
 			k.buf.Reset()
 		}
-		fmt.Fprintf(w, "\x1B_Ga=p,i=%d,p=%d,C=1\x1B\\", k.id, pid)
+		seq := fmt.Sprintf("\x1B_Ga=p,i=%d,p=%d,C=1\x1B\\", k.id, pid)
+		io.WriteString(w, seq)
 	}
 	deleteFunc := func(w io.Writer) {
-		fmt.Fprintf(w, "\x1B_Ga=d,d=i,i=%d,p=%d\x1B\\", k.id, pid)
+		seq := fmt.Sprintf("\x1B_Ga=d,d=i,i=%d,p=%d\x1B\\", k.id, pid)
+		io.WriteString(w, seq)
+	}
+	placement := &placement{
+		col:      col,
+		row:      row,
+		id:       k.id,
+		w:        k.w,
+		h:        k.h,
+		writeTo:  writeFunc,
+		deleteFn: deleteFunc,
+	}
+	k.vx.graphicsNext = append(k.vx.graphicsNext, placement)
+}
+
+// drawUnicodePlaceholder renders a kitty image via Unicode placeholders.
+// This is used inside tmux where direct kitty placement commands (a=p)
+// position images at absolute terminal coordinates, ignoring pane offsets.
+// Unicode placeholders are just text characters that tmux handles as normal
+// cell content, so they naturally appear at the correct pane-relative position.
+func (k *KittyImage) drawUnicodePlaceholder(win Window) {
+	w, h := win.Size()
+	if w <= 0 || h <= 0 {
+		return
+	}
+	col, row := win.Origin()
+
+	// Clamp to the visible area.  The kitty spec allows emitting fewer
+	// placeholder cells than the virtual placement dimensions — the
+	// terminal will display only the corresponding portion of the image.
+	drawW := k.w
+	drawH := k.h
+	if drawW > w {
+		drawW = w
+	}
+	if drawH > h {
+		drawH = h
+	}
+	log.Trace("placing kitty image via unicode placeholder at cell %d,%d (%dx%d, visible %dx%d)",
+		col, row, k.w, k.h, drawW, drawH)
+
+	// Encode image ID as a 24-bit RGB foreground color.  We always use
+	// RGB rather than 256-color IndexColor because index colors 0-15 are
+	// ANSI palette entries that terminals may remap, which would corrupt
+	// the ID the terminal decodes from the placeholder's foreground color.
+	r := uint8((k.id >> 16) & 0xFF)
+	g := uint8((k.id >> 8) & 0xFF)
+	b := uint8(k.id & 0xFF)
+	fgColor := RGBColor(r, g, b)
+
+	// Write placeholder characters into the window cells.
+	// Each cell gets U+10EEEE + row diacritic + column diacritic,
+	// with the image ID encoded in the foreground color.
+	for y := 0; y < drawH; y++ {
+		for x := 0; x < drawW; x++ {
+			g := placeholderGrapheme(y, x)
+			win.SetCell(x, y, Cell{
+				Character: Character{
+					Grapheme: g,
+					Width:    1,
+				},
+				Style: Style{
+					Foreground: fgColor,
+				},
+			})
+		}
+	}
+
+	// Create a placement that uploads the image data (first time) and
+	// creates the virtual placement needed for Unicode placeholders.
+	writeFunc := func(wr io.Writer) {
+		if !atomicLoad(&k.uploaded) {
+			wr.Write(k.buf.Bytes())
+			atomicStore(&k.uploaded, true)
+			k.buf.Reset()
+		}
+		// Create virtual placement: tells the terminal to associate
+		// this image ID with the Unicode placeholder characters.
+		seq := fmt.Sprintf("\x1B_Ga=p,U=1,i=%d,c=%d,r=%d,q=2\x1B\\",
+			k.id, k.w, k.h)
+		io.WriteString(wr, tmuxWrap(seq))
+	}
+	deleteFunc := func(wr io.Writer) {
+		// Delete by image ID — removes the virtual placement
+		seq := fmt.Sprintf("\x1B_Ga=d,d=i,i=%d,q=2\x1B\\", k.id)
+		io.WriteString(wr, tmuxWrap(seq))
 	}
 	placement := &placement{
 		col:      col,
@@ -116,7 +267,13 @@ func (k *KittyImage) Draw(win Window) {
 
 // Destroy deletes this image from memory
 func (k *KittyImage) Destroy() {
-	fmt.Fprintf(k.vx.console, "\x1B_Ga=d,d=I,i=%d\x1B\\", k.id)
+	var seq string
+	if k.vx.inTmux {
+		seq = tmuxWrap(fmt.Sprintf("\x1B_Ga=d,d=I,i=%d,q=2\x1B\\", k.id))
+	} else {
+		seq = fmt.Sprintf("\x1B_Ga=d,d=I,i=%d\x1B\\", k.id)
+	}
+	io.WriteString(k.vx.console, seq)
 }
 
 func (k *KittyImage) CellSize() (w int, h int) {
@@ -166,7 +323,13 @@ func (k *KittyImage) Resize(w int, h int) {
 			if buf.Len() == 0 {
 				m = 0
 			}
-			fmt.Fprintf(k.buf, "\x1B_Gf=100,i=%d,m=%d;%s\x1B\\", k.id, m, string(b[:n]))
+			var seq string
+			if k.vx.inTmux {
+				seq = tmuxWrap(fmt.Sprintf("\x1B_Gf=100,i=%d,m=%d,q=2;%s\x1B\\", k.id, m, string(b[:n])))
+			} else {
+				seq = fmt.Sprintf("\x1B_Gf=100,i=%d,m=%d;%s\x1B\\", k.id, m, string(b[:n]))
+			}
+			k.buf.WriteString(seq)
 		}
 		k.vx.PostEventBlocking(Redraw{})
 	}()
diff --git a/placeholder_test.go b/placeholder_test.go
new file mode 100644
index 0000000..a0b6d40
--- /dev/null
+++ b/placeholder_test.go
@@ -0,0 +1,85 @@
+package vaxis
+
+import (
+	"testing"
+)
+
+func TestPlaceholderGrapheme(t *testing.T) {
+	// Row 0, Col 0 should be U+10EEEE + U+0305 (row 0) + U+0305 (col 0)
+	g := placeholderGrapheme(0, 0)
+	expected := "\U0010EEEE\u0305\u0305"
+	if g != expected {
+		t.Errorf("placeholderGrapheme(0,0) = %q, want %q", g, expected)
+	}
+
+	// Row 1, Col 0 should be U+10EEEE + U+030D (row 1) + U+0305 (col 0)
+	g = placeholderGrapheme(1, 0)
+	expected = "\U0010EEEE\u030D\u0305"
+	if g != expected {
+		t.Errorf("placeholderGrapheme(1,0) = %q, want %q", g, expected)
+	}
+
+	// Row 0, Col 1 should be U+10EEEE + U+0305 (row 0) + U+030D (col 1)
+	g = placeholderGrapheme(0, 1)
+	expected = "\U0010EEEE\u0305\u030D"
+	if g != expected {
+		t.Errorf("placeholderGrapheme(0,1) = %q, want %q", g, expected)
+	}
+
+	// Row 2, Col 3 should be U+10EEEE + U+030E (row 2) + U+0310 (col 3)
+	g = placeholderGrapheme(2, 3)
+	expected = "\U0010EEEE\u030E\u0310"
+	if g != expected {
+		t.Errorf("placeholderGrapheme(2,3) = %q, want %q", g, expected)
+	}
+}
+
+func TestPlaceholderGraphemeOutOfRange(t *testing.T) {
+	// Beyond the diacritics table — should omit the out-of-range diacritics
+	big := len(rowColDiacritics) + 10
+
+	// Both out of range: just the placeholder char, no diacritics
+	g := placeholderGrapheme(big, big)
+	if g != placeholderChar {
+		t.Errorf("placeholderGrapheme(%d,%d) = %q, want %q", big, big, g, placeholderChar)
+	}
+
+	// Row in range, col out of range: placeholder + row diacritic only
+	g = placeholderGrapheme(0, big)
+	expected := "\U0010EEEE\u0305"
+	if g != expected {
+		t.Errorf("placeholderGrapheme(0,%d) = %q, want %q", big, g, expected)
+	}
+
+	// Row out of range, col in range: placeholder + col diacritic only
+	// (spec doesn't define this case but our function adds what it can)
+	g = placeholderGrapheme(big, 0)
+	expected = "\U0010EEEE\u0305"
+	if g != expected {
+		t.Errorf("placeholderGrapheme(%d,0) = %q, want %q", big, g, expected)
+	}
+}
+
+func TestRowColDiacriticsTable(t *testing.T) {
+	// Verify first few entries match the kitty spec
+	expected := []rune{0x0305, 0x030D, 0x030E, 0x0310, 0x0312}
+	for i, want := range expected {
+		if rowColDiacritics[i] != want {
+			t.Errorf("rowColDiacritics[%d] = %U, want %U", i, rowColDiacritics[i], want)
+		}
+	}
+
+	// Table should have 256 entries
+	if len(rowColDiacritics) != 256 {
+		t.Errorf("rowColDiacritics has %d entries, want 256", len(rowColDiacritics))
+	}
+
+	// All entries should be unique
+	seen := make(map[rune]int)
+	for i, r := range rowColDiacritics {
+		if prev, ok := seen[r]; ok {
+			t.Errorf("rowColDiacritics[%d] = %U duplicates entry [%d]", i, r, prev)
+		}
+		seen[r] = i
+	}
+}
diff --git a/tmux.go b/tmux.go
new file mode 100644
index 0000000..a9805c3
--- /dev/null
+++ b/tmux.go
@@ -0,0 +1,17 @@
+package vaxis
+
+import "strings"
+
+// tmuxWrap wraps an escape sequence in a tmux DCS passthrough envelope.
+// tmux requires that applications wrap escape sequences in:
+//
+//	ESC P tmux; <sequence-with-doubled-escapes> ESC \
+//
+// Every ESC (0x1B) byte inside the payload must be doubled.
+// This is required for kitty graphics (APC sequences) to reach the
+// outer terminal when running inside tmux with allow-passthrough on.
+func tmuxWrap(seq string) string {
+	// Double all ESC bytes in the payload
+	escaped := strings.ReplaceAll(seq, "\x1b", "\x1b\x1b")
+	return "\x1bPtmux;" + escaped + "\x1b\\"
+}
diff --git a/vaxis.go b/vaxis.go
index a6980d6..1b3192c 100644
--- a/vaxis.go
+++ b/vaxis.go
@@ -131,6 +131,7 @@ type Vaxis struct {
 	userCursorStyle  CursorStyle
 
 	xtwinops bool
+	inTmux   bool // running inside tmux; kitty graphics need DCS passthrough
 
 	withTty     string
 	withConsole console.Console
@@ -373,6 +374,11 @@ outer:
 		}
 	}
 
+	// Detect tmux so kitty graphics can be wrapped in DCS passthrough
+	if os.Getenv("TMUX") != "" {
+		vx.inTmux = true
+	}
+
 	ws, err := vx.reportWinsize()
 	if err != nil {
 		return nil, err
