#!/bin/sh

# POSIX shell script to detect and upgrade current nix configuration
# Handles both system configurations and home-manager configurations

set -e

# Nix command flags for experimental features
NIX_FLAGS="--extra-experimental-features nix-command --extra-experimental-features flakes"

# Colors for output
blue=$'\033[38;5;4m'
green=$'\033[38;5;85m'
red=$'\033[38;5;1m'
orange=$'\033[38;5;208m'
cyan=$'\033[38;5;6m'
bold=$'\033[1m'
reset=$'\033[m'

# Inputs excluded from updates by default (space-separated)
DEFAULT_EXCLUDED_INPUTS="opencode"

# Function to print colored output
print_info() {
    printf "${blue}[INFO]${reset} %s\n" "$1"
}

print_success() {
    printf "${green}[SUCCESS]${reset} %s\n" "$1"
}

print_error() {
    printf "${red}[ERROR]${reset} %s\n" "$1"
}

print_warning() {
    printf "${orange}[WARNING]${reset} %s\n" "$1"
}

# Function to get all flake inputs from lockfile
get_flake_inputs() {
    local flake_dir="${HOME}/.config/nixpkgs"
    jq -r '.nodes.root.inputs | keys[]' "${flake_dir}/flake.lock"
}

# Function to check if a value is in a space-separated list
list_contains() {
    local list="$1"
    local item="$2"
    for i in $list; do
        if [ "$i" = "$item" ]; then
            return 0
        fi
    done
    return 1
}

# Function to add item to space-separated list (if not already present)
list_add() {
    local list="$1"
    local item="$2"
    if ! list_contains "$list" "$item"; then
        if [ -z "$list" ]; then
            echo "$item"
        else
            echo "$list $item"
        fi
    else
        echo "$list"
    fi
}

# Function to remove item from space-separated list
list_remove() {
    local list="$1"
    local item="$2"
    local result=""
    for i in $list; do
        if [ "$i" != "$item" ]; then
            if [ -z "$result" ]; then
                result="$i"
            else
                result="$result $i"
            fi
        fi
    done
    echo "$result"
}

# Function to detect system type and available configurations
detect_system() {
    local system_type=""
    local has_system_config=false
    local has_home_config=false

    # Detect system type
    case "$(uname -s)" in
        Darwin)
            system_type="darwin"
            # Check if we have nix-darwin
            if command -v darwin-rebuild >/dev/null 2>&1; then
                has_system_config=true
            fi
            ;;
        Linux)
            system_type="linux"
            # Check if we have nixos
            if command -v nixos-rebuild >/dev/null 2>&1; then
                has_system_config=true
            fi
            ;;
        *)
            print_error "Unsupported system: $(uname -s)"
            exit 1
            ;;
    esac

    # Check if we have standalone home-manager CLI.
    # When home-manager is integrated into darwin/nixos (via darwinModules or
    # nixosModules), the CLI typically isn't available as a standalone command,
    # so this check effectively distinguishes integrated vs standalone setups.
    if command -v home-manager >/dev/null 2>&1; then
        has_home_config=true
    fi

    echo "${system_type}:${has_system_config}:${has_home_config}"
}

# Function to detect current home-manager configuration
detect_home_config() {
    local username="$(whoami)"
    local system_type="$1"

    # Check if we're in a known work environment
    local config_type="personal"
    if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ] || [ "$(ps -o comm= -p $PPID)" = "sshd" ]; then
        # Likely an SSH session to a server
        config_type="server"
    elif [ "$username" = "toma" ]; then
        config_type="work"
    fi

    echo "${username}@${config_type}"
}

# Function to detect current system configuration
detect_system_config() {
    echo "$(hostname)"
}

# Function to check if configuration exists in flake
check_config_exists() {
    local config_type="$1"  # "system" or "home"
    local config_name="$2"
    local flake_dir="${HOME}/.config/nixpkgs"

    if [ ! -f "${flake_dir}/flake.nix" ]; then
        print_error "Flake not found at ${flake_dir}/flake.nix"
        exit 1
    fi

    local flake_attr=""
    case "$config_type" in
        system)
            case "$(uname -s)" in
                Darwin) flake_attr="darwinConfigurations" ;;
                Linux) flake_attr="nixosConfigurations" ;;
            esac
            ;;
        home)
            flake_attr="homeConfigurations"
            ;;
    esac

    # Check if the configuration exists in the flake
    local config_exists=$(nix eval ${NIX_FLAGS} "${flake_dir}#${flake_attr}" --apply "builtins.hasAttr \"${config_name}\"" 2>/dev/null)
    if [ "$config_exists" != "true" ]; then
        print_error "Configuration '${config_name}' not found in ${flake_attr}"
        print_info "Available configurations:"
        nix eval ${NIX_FLAGS} "${flake_dir}#${flake_attr}" --apply builtins.attrNames
        exit 1
    fi
}

# Function to update flake inputs
update_flake() {
    local flake_dir="${HOME}/.config/nixpkgs"

    print_info "Updating flake inputs..."

    # First, sync flake.lock with flake.nix (adds new inputs, removes deleted ones)
    if ! nix flake lock ${NIX_FLAGS} "$flake_dir"; then
        print_error "Failed to lock flake"
        exit 1
    fi

    # Get current inputs from metadata
    local all_inputs=$(get_flake_inputs)

    # Validate explicitly mentioned inputs (error if not found)
    validate_explicit_inputs "$all_inputs" "$MENTIONED_INPUTS"

    # Validate default exclusions (warn if not found, remove from list)
    validate_default_exclusions "$all_inputs"

    # Build lists of inputs to update and skip
    local to_update=""
    local to_skip=""
    for input in $all_inputs; do
        if list_contains "$EXCLUDED_INPUTS" "$input"; then
            to_skip=$(list_add "$to_skip" "$input")
        else
            to_update=$(list_add "$to_update" "$input")
        fi
    done

    # Print what we're doing
    if [ -n "$to_skip" ]; then
        print_info "Skipping: ${cyan}${to_skip}${reset}"
    fi
    if [ -n "$to_update" ]; then
        print_info "Updating: ${cyan}${to_update}${reset}"
    fi

    # Run the update if there are inputs to update
    if [ -n "$to_update" ]; then
        if ! nix flake update ${NIX_FLAGS} $to_update --flake "$flake_dir"; then
            print_error "Failed to update flake inputs"
            exit 1
        fi
    else
        print_info "No inputs to update"
    fi
}

# Function to update system configuration
update_system() {
    local config_name="$1"
    local flake_dir="${HOME}/.config/nixpkgs"

    print_info "Switching to system configuration: ${bold}${config_name}${reset}"

    case "$(uname -s)" in
        Darwin)
            if ! sudo darwin-rebuild switch --flake "${flake_dir}#${config_name}"; then
                print_error "Failed to switch to darwin configuration '${config_name}'"
                exit 1
            fi
            ;;
        Linux)
            if ! sudo nixos-rebuild switch --flake "${flake_dir}#${config_name}"; then
                print_error "Failed to switch to nixos configuration '${config_name}'"
                exit 1
            fi
            ;;
    esac

    print_success "Successfully updated system configuration '${config_name}'"
}

# Function to update home-manager configuration
update_home() {
    local config_name="$1"
    local flake_dir="${HOME}/.config/nixpkgs"

    print_info "Switching to home-manager configuration: ${bold}${config_name}${reset}"
    if ! home-manager switch ${NIX_FLAGS} --flake "${flake_dir}#${config_name}"; then
        print_error "Failed to switch to home-manager configuration '${config_name}'"
        exit 1
    fi

    print_success "Successfully updated home-manager configuration '${config_name}'"
}

# Function to show available update modes
show_modes() {
    local system_info="$1"
    local system_type="$(echo "$system_info" | cut -d: -f1)"
    local has_system="$(echo "$system_info" | cut -d: -f2)"
    local has_home="$(echo "$system_info" | cut -d: -f3)"

    print_info "Available update modes on ${system_type}:"

    if [ "$has_system" = "true" ]; then
        case "$system_type" in
            darwin) print_info "  ${bold}system${reset} - Update nix-darwin system configuration" ;;
            linux) print_info "  ${bold}system${reset} - Update NixOS system configuration" ;;
        esac
    fi

    if [ "$has_home" = "true" ]; then
        print_info "  ${bold}home${reset} - Update home-manager configuration"
    fi

    print_info "  ${bold}both${reset} - Update both system and home-manager (if available)"
}

# Main execution
main() {
    local mode="$1"
    local config_override="$2"

    # Detect system capabilities
    local system_info="$(detect_system)"
    local system_type="$(echo "$system_info" | cut -d: -f1)"
    local has_system="$(echo "$system_info" | cut -d: -f2)"
    local has_home="$(echo "$system_info" | cut -d: -f3)"

    # Default mode selection
    if [ -z "$mode" ]; then
        if [ "$has_system" = "true" ] && [ "$has_home" = "true" ]; then
            mode="both"
        elif [ "$has_system" = "true" ]; then
            mode="system"
        elif [ "$has_home" = "true" ]; then
            mode="home"
        else
            print_error "No nix configurations available (no darwin-rebuild, nixos-rebuild, or home-manager found)"
            exit 1
        fi
    fi

    print_info "Update mode: ${bold}${mode}${reset}"

    # Update flake inputs once
    update_flake

    # Handle different modes
    case "$mode" in
        system)
            if [ "$has_system" != "true" ]; then
                print_error "System configuration not available on this system"
                exit 1
            fi

            local system_config="${config_override:-$(detect_system_config "$system_type")}"
            check_config_exists "system" "$system_config"
            update_system "$system_config"
            ;;

        home)
            if [ "$has_home" != "true" ]; then
                print_error "Home-manager not available on this system"
                exit 1
            fi

            local home_config="${config_override:-$(detect_home_config "$system_type")}"
            check_config_exists "home" "$home_config"
            update_home "$home_config"
            ;;

        both)
            if [ "$has_system" = "true" ]; then
                local system_config="$(detect_system_config "$system_type")"
                check_config_exists "system" "$system_config"
                update_system "$system_config"
            fi

            if [ "$has_home" = "true" ]; then
                local home_config="$(detect_home_config "$system_type")"
                check_config_exists "home" "$home_config"
                update_home "$home_config"
            fi
            ;;

        *)
            print_error "Invalid mode: $mode"
            show_modes "$system_info"
            exit 1
            ;;
    esac
}

# Parse input inclusion/exclusion flags
# These must be parsed before other arguments
# Uses two-pass approach so flag ordering doesn't matter
parse_input_flags() {
    USE_ALL=false
    USE_NONE=false
    EXPLICIT_INCLUDES=""
    EXPLICIT_EXCLUDES=""
    MENTIONED_INPUTS=""
    REMAINING_ARGS=""

    # First pass: collect all flags
    while [ $# -gt 0 ]; do
        case "$1" in
            --all)
                USE_ALL=true
                ;;
            --none)
                USE_NONE=true
                ;;
            --no-*)
                local input_name="${1#--no-}"
                EXPLICIT_EXCLUDES=$(list_add "$EXPLICIT_EXCLUDES" "$input_name")
                MENTIONED_INPUTS=$(list_add "$MENTIONED_INPUTS" "$input_name")
                ;;
            --help|-h)
                # Show help and exit immediately
                show_help
                exit 0
                ;;
            --*)
                local input_name="${1#--}"
                EXPLICIT_INCLUDES=$(list_add "$EXPLICIT_INCLUDES" "$input_name")
                MENTIONED_INPUTS=$(list_add "$MENTIONED_INPUTS" "$input_name")
                ;;
            *)
                # Non-flag arguments (mode, config name)
                if [ -z "$REMAINING_ARGS" ]; then
                    REMAINING_ARGS="$1"
                else
                    REMAINING_ARGS="$REMAINING_ARGS $1"
                fi
                ;;
        esac
        shift
    done

    # Detect conflicts: --all and --none
    if [ "$USE_ALL" = "true" ] && [ "$USE_NONE" = "true" ]; then
        print_warning "'--all' and '--none' both specified; using '--none'"
        USE_ALL=false
    fi

    # Detect conflicts: input in both includes and excludes
    for input in $EXPLICIT_INCLUDES; do
        if list_contains "$EXPLICIT_EXCLUDES" "$input"; then
            print_warning "'$input' was both included and excluded; excluding"
            # Remove from includes (excludes take precedence)
            EXPLICIT_INCLUDES=$(list_remove "$EXPLICIT_INCLUDES" "$input")
        fi
    done

    # Second pass: build final exclusion list
    if [ "$USE_NONE" = "true" ]; then
        # Start with all inputs excluded, only update explicit includes
        EXCLUDED_INPUTS=$(get_flake_inputs | tr '\n' ' ')
        # Add explicit excludes (redundant but consistent)
        for input in $EXPLICIT_EXCLUDES; do
            EXCLUDED_INPUTS=$(list_add "$EXCLUDED_INPUTS" "$input")
        done
        # Remove explicit includes
        for input in $EXPLICIT_INCLUDES; do
            EXCLUDED_INPUTS=$(list_remove "$EXCLUDED_INPUTS" "$input")
        done
    elif [ "$USE_ALL" = "true" ]; then
        # Start with empty, only add explicit excludes
        EXCLUDED_INPUTS="$EXPLICIT_EXCLUDES"
    else
        # Start with defaults
        EXCLUDED_INPUTS="$DEFAULT_EXCLUDED_INPUTS"
        # Add explicit excludes
        for input in $EXPLICIT_EXCLUDES; do
            EXCLUDED_INPUTS=$(list_add "$EXCLUDED_INPUTS" "$input")
        done
        # Remove explicit includes
        for input in $EXPLICIT_INCLUDES; do
            EXCLUDED_INPUTS=$(list_remove "$EXCLUDED_INPUTS" "$input")
        done
    fi
}

# Validate explicitly mentioned inputs exist (error if not)
validate_explicit_inputs() {
    local flake_inputs="$1"
    local mentioned="$2"

    for input in $mentioned; do
        if ! list_contains "$flake_inputs" "$input"; then
            print_error "Unknown input: '$input'"
            # Convert newlines to spaces for display
            local inputs_display=$(echo $flake_inputs | tr '\n' ' ')
            print_info "Available inputs: $inputs_display"
            exit 1
        fi
    done
}

# Validate default excluded inputs exist (warn if not, remove from list)
validate_default_exclusions() {
    local flake_inputs="$1"
    local validated_exclusions=""

    for input in $EXCLUDED_INPUTS; do
        if list_contains "$flake_inputs" "$input"; then
            validated_exclusions=$(list_add "$validated_exclusions" "$input")
        elif list_contains "$DEFAULT_EXCLUDED_INPUTS" "$input" && ! list_contains "$EXPLICIT_EXCLUDES" "$input"; then
            # Only warn for default exclusions, not explicit ones (those error in validate_explicit_inputs)
            print_warning "Excluded input '$input' does not exist in flake"
        fi
    done

    EXCLUDED_INPUTS="$validated_exclusions"
}

# Show help message
show_help() {
    cat << EOF
Usage: $0 [OPTIONS] [MODE] [CONFIG_NAME]

Detects and upgrades nix configurations (system and/or home-manager).

MODES:
  system    Update system configuration (nix-darwin/NixOS)
  home      Update home-manager configuration
  both      Update both system and home-manager (default if both available)

INPUT OPTIONS:
  --all           Update all flake inputs (ignore default exclusions)
  --none          Skip all flake input updates (use with --<input> to include specific inputs)
  --<input>       Include <input> in update (override default exclusion)
  --no-<input>    Exclude <input> from update

By default, these inputs are excluded: ${DEFAULT_EXCLUDED_INPUTS}

If CONFIG_NAME is provided, uses that configuration instead of auto-detection.

Auto-detection logic:
  System configs: hostname
  Home configs: toma@work (macOS), username@server (SSH), username@personal (default)

Examples:
  $0                        # Auto-detect mode and configs (excludes: ${DEFAULT_EXCLUDED_INPUTS})
  $0 system                 # Update system only
  $0 home                   # Update home-manager only
  $0 both                   # Update both
  $0 home toma@server       # Update specific home config
  $0 system apollo          # Update specific system config
  $0 --opencode             # Include opencode (overrides default exclusion)
  $0 --all                  # Update all inputs
  $0 --all --no-opencode    # Update all inputs except opencode
  $0 --no-zen-browser       # Exclude zen-browser in addition to defaults
  $0 --none                 # Skip all flake updates (just rebuild)
  $0 --none --nixpkgs       # Only update nixpkgs

EOF
}

# Parse input flags and extract remaining arguments
parse_input_flags "$@"

# shellcheck disable=SC2086
main $REMAINING_ARGS
